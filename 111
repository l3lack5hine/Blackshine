package your.group.id; // เปลี่ยนเป็น package ที่คุณต้องการ

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.BlockPosition;
import com.comphenix.protocol.wrappers.WrappedBlockData;
import com.fastasyncworldedit.core.FaweAPI;
import com.fastasyncworldedit.core.world.FaweWorld;
import com.fastasyncworldedit.core.world.block.FaweBlockQueue;
import me.clip.placeholderapi.PlaceholderAPI;
import net.milkbowl.vault.economy.Economy;
import net.milkbowl.vault.economy.EconomyResponse;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.RegisteredServiceProvider;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.Vector;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Level;

public class BuildingRecorder extends JavaPlugin implements Listener {

    private Material selectionItem;
    private final Map<UUID, Location> pos1Map = new HashMap<>();
    private final Map<UUID, Location> pos2Map = new HashMap<>();
    private File dataFolder;
    private final Map<UUID, String> selectedFileMap = new HashMap<>();
    private final Map<UUID, List<Location>> guideBlocksMap = new HashMap<>();
    private double costMultiplier;
    private boolean usePlaceholderAPI;
    private boolean useEconomy;
    private double recordCost;
    private static Economy economy = null;
    private ProtocolManager protocolManager;
    private boolean useFawe;
    private boolean useProtocolLib;

    @Override
    public void onEnable() {
        getServer().getPluginManager().registerEvents(this, this);
        loadConfig();
        dataFolder = new File(getDataFolder(), "buildings-fawe");
        if (!dataFolder.exists()) {
            dataFolder.mkdirs();
        }
        usePlaceholderAPI = Bukkit.getPluginManager().isPluginEnabled("PlaceholderAPI");
        if (usePlaceholderAPI) {
            getLogger().info("รองรับ PlaceholderAPI แล้ว!");
        } else {
            getLogger().warning("ไม่พบ PlaceholderAPI! Placeholders จะไม่ทำงาน.");
        }
        useEconomy = setupEconomy();
        if (useEconomy) {
            getLogger().info("รองรับ Vault Economy แล้ว! ค่าบันทึก: " + recordCost);
        } else {
            getLogger().warning("ไม่พบ Vault Economy! จะไม่คิดค่าบันทึก.");
        }
        useProtocolLib = Bukkit.getPluginManager().isPluginEnabled("ProtocolLib");
        if (useProtocolLib) {
            protocolManager = ProtocolLibrary.getProtocolManager();
            getLogger().info("รองรับ ProtocolLib แล้ว!");
            registerProtocolListener();
        } else {
            getLogger().warning("ไม่พบ ProtocolLib! การแสดงเส้นไกด์อาจไม่ราบรื่น.");
        }
        useFawe = Bukkit.getPluginManager().isPluginEnabled("FastAsyncWorldEdit");
        if (useFawe) {
            getLogger().info("รองรับ FastAsyncWorldEdit แล้ว! จะใช้เพื่อการบันทึกและวาง.");
        } else {
            getLogger().warning("ไม่พบ FastAsyncWorldEdit! จะใช้ Bukkit API ในการบันทึกและวาง.");
        }
        getLogger().info("ปลั๊กอิน BuildingRecorder เปิดใช้งานแล้ว!");
    }

    @Override
    public void onDisable() {
        clearAllGuides();
        getLogger().info("ปลั๊กอิน BuildingRecorder ปิดใช้งานแล้ว!");
    }

    public void loadConfig() {
        getConfig().options().copyDefaults(true);
        getConfig().addDefault("selection-item", "STICK");
        getConfig().addDefault("cost-multiplier", 1.0);
        getConfig().addDefault("record-cost", 0.0);
        saveConfig();

        String itemName = getConfig().getString("selection-item", "STICK").toUpperCase();
        try {
            selectionItem = Material.valueOf(itemName);
        } catch (IllegalArgumentException e) {
            getLogger().warning("ไม่พบไอเทม '" + itemName + "' ในการตั้งค่า! ใช้แท่งไม้ (STICK) แทน");
            selectionItem = Material.STICK;
        }
        costMultiplier = getConfig().getDouble("cost-multiplier", 1.0);
        recordCost = getConfig().getDouble("record-cost", 0.0);
    }

    private boolean setupEconomy() {
        if (getServer().getPluginManager().getPlugin("Vault") == null) {
            return false;
        }
        RegisteredServiceProvider<Economy> rsp = getServer().getServicesManager().getRegistration(Economy.class);
        if (rsp == null) {
            return false;
        }
        economy = rsp.getProvider();
        return economy != null;
    }

    private String applyPlaceholders(Player player, String message) {
        if (usePlaceholderAPI && player != null) {
            return PlaceholderAPI.setPlaceholders(player, message);
        }
        return message;
    }

    private void registerProtocolListener() {
        protocolManager.addPacketListener(
                new PacketAdapter(this, ListenerPriority.NORMAL, PacketType.Play.Server.BLOCK_CHANGE) {
                    @Override
                    public void onPacketSending(PacketEvent event) {
                        // สามารถเพิ่มการตรวจสอบ Packet ที่ส่งออกได้ที่นี่ (ถ้าจำเป็น)
                    }
                });
    }

    @EventHandler
    public void onPlayerInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        ItemStack item = event.getItem();
        UUID playerId = player.getUniqueId();

        if (item != null && item.getType() == selectionItem && event.getAction().toString().startsWith("RIGHT_CLICK")) {
            Block clickedBlock = event.getClickedBlock();
            if (clickedBlock != null) {
                if (!pos1Map.containsKey(playerId)) {
                    pos1Map.put(playerId, clickedBlock.getLocation());
                    player.sendMessage(applyPlaceholders(player, "§a[BuildingRecorder] กำหนดจุดที่ 1 แล้ว: %block_x%, %block_y%, %block_z%".replace("%block_x%", String.valueOf(clickedBlock.getX())).replace("%block_y%", String.valueOf(clickedBlock.getY())).replace("%block_z%", String.valueOf(clickedBlock.getZ()))));
                } else if (!pos2Map.containsKey(playerId)) {
                    pos2Map.put(playerId, clickedBlock.getLocation());
                    player.sendMessage(applyPlaceholders(player, "§a[BuildingRecorder] กำหนดจุดที่ 2 แล้ว: %block_x%, %block_y%, %block_z%".replace("%block_x%", String.valueOf(clickedBlock.getX())).replace("%block_y%", String.valueOf(clickedBlock.getY())).replace("%block_z%", String.valueOf(clickedBlock.getZ()))));
                    calculateAndRecordArea(player);
                } else {
                    pos1Map.put(playerId, clickedBlock.getLocation());
                    pos2Map.remove(playerId);
                    player.sendMessage(applyPlaceholders(player, "§a[BuildingRecorder] กำหนดจุดที่ 1 ใหม่แล้ว: %block_x%, %block_y%, %block_z%".replace("%block_x%", String.valueOf(clickedBlock.getX())).replace("%block_y%", String.valueOf(clickedBlock.getY())).replace("%block_z%", String.valueOf(clickedBlock.getZ()))));
                    player.sendMessage(applyPlaceholders(player, "§e[BuildingRecorder] โปรดคลิกขวาที่อีกมุมหนึ่งเพื่อกำหนดจุดที่ 2"));
                }
                event.setCancelled(true);
            }
        }
    }

    private void calculateAndRecordArea(Player player) {
        UUID playerId = player.getUniqueId();
        if (pos1Map.containsKey(playerId) && pos2Map.containsKey(playerId) && pos1Map.get(playerId).getWorld().equals(pos2Map.get(playerId).getWorld())) {
            Location loc1 = pos1Map.get(playerId);
            Location loc2 = pos2Map.get(playerId);
            World world = loc1.getWorld();
            int minX = Math.min(loc1.getBlockX(), loc2.getBlockX());
            int maxX = Math.max(loc1.getBlockX(), loc2.getBlockX());
            int minY = Math.min(loc1.getBlockY(), loc2.getBlockY());
            int maxY = Math.max(loc1.getBlockY(), loc2.getBlockY());
            int minZ = Math.min(loc1.getBlockZ(), loc2.getBlockZ());
            int maxZ = Math.max(loc1.getBlockZ(), loc2.getBlockZ());

            File playerFolder = new File(dataFolder, playerId.toString());
            if (!playerFolder.exists()) {
                playerFolder.mkdirs();
            }
            File buildingFile = new File(playerFolder, "building_" + System.currentTimeMillis() + ".bin");

            if (useEconomy && recordCost > 0) {
                if (economy.has(player, recordCost)) {
                    EconomyResponse r = economy.withdrawPlayer(player, recordCost);
                    if (r.transactionSuccess()) {
                        if (useFawe) {
                            recordWithFawe(player, world, minX, minY, minZ, maxX, maxY, maxZ, buildingFile);
                        } else {
                            recordWithBukkit(player, world, minX, minY, minZ, maxX, maxY, maxZ, buildingFile);
                        }
                        pos1Map.remove(playerId);
                        pos2Map.remove(playerId);
                    } else {
                        player.sendMessage(applyPlaceholders(player, "§c[BuildingRecorder] ไม่สามารถหักค่าบันทึกได้: %error%".replace("%error%", r.errorMessage)));
                    }
                } else {
                    player.sendMessage(applyPlaceholders(player, "§c[BuildingRecorder] คุณไม่มีเงินเพียงพอสำหรับค่าบันทึก (%record_cost% %currency%)!".replace("%record_cost%", String.valueOf(recordCost)).replace("%currency%", economy.currencyName())));
                }
            } else {
                if (useFawe) {
                    recordWithFawe(player, world, minX, minY, minZ, maxX, maxY, maxZ, buildingFile);
                } else {
                    recordWithBukkit(player, world, minX, minY, minZ, maxX, maxY, maxZ, buildingFile);
                }
                pos1Map.remove(playerId);
                pos2Map.remove(playerId);
            }
        } else {
            player.sendMessage(applyPlaceholders(player, "§c[BuildingRecorder] โปรดกำหนดจุดทั้งสองก่อน!"));
        }
    }

    private void recordWithBukkit(Player player, World world, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, File buildingFile) {
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(buildingFile))) {
            dos.writeUTF(world.getName());
            int count = 0;
            for (int x = minX; x <= maxX; x++) {
                for (int y = minY; y <= maxY; y++) {
                    for (int z = minZ; z <= maxZ; z++) {
                        Block block = world.getBlockAt(x, y, z);
                        dos.writeInt(x);
                        dos.writeInt(y);
                        dos.writeInt(z);
                        dos.writeUTF(block.getType().name());
                        count++;
                    }
                }
            }
            player.sendMessage(applyPlaceholders(player, "§b[BuildingRecorder] บันทึกพื้นที่แล้ว (%block_count% บล็อก) ในโฟลเดอร์: buildings-fawe/%player_uuid%/%file_name%".replace("%block_count%", String.valueOf(count)).replace("%player_uuid%", player.getUniqueId().toString()).replace("%file_name%", buildingFile.getName())));
        } catch (IOException e) {
            getLogger().log(Level.SEVERE, "เกิดข้อผิดพลาดในการเขียนไฟล์ Binary (Bukkit)!", e);
            player.sendMessage(applyPlaceholders(player, "§c[BuildingRecorder] เกิดข้อผิดพลาดในการบันทึก!"));
            if (useEconomy && recordCost > 0) economy.depositPlayer(player, recordCost);
        }
    }

    private void recordWithFawe(Player player, World world, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, File buildingFile) {
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(buildingFile))) {
            dos.writeUTF(world.getName());
            FaweWorld faweWorld = FaweAPI.wrap(world);
            FaweBlockQueue queue = new FaweBlockQueue(faweWorld.getName(), true);
            int count = 0;
            for (int x = minX; x <= maxX; x++) {
                for (int y = minY; y <= maxY; y++) {
                    for (int z = minZ; z <= maxZ; z++) {
                        org.bukkit.block.data.BlockData blockData = world.getBlockAt(x, y, z).getBlockData();
                        queue.setBlock(x, y, z, FaweAPI.wrap(blockData));
                        dos.writeInt(x);
                        dos.writeInt(y);
                        dos.writeInt(z);
                        dos.writeUTF(blockData.getMaterial().name());
                        count++;
                    }
                }
            }
            queue.flush();
            player.sendMessage(applyPlaceholders(player, "§b[BuildingRecorder] บันทึกพื้นที่แล้ว (%block_count% บล็อก) ด้วย FastAsyncWorldEdit ในโฟลเดอร์: buildings-fawe/%player_uuid%/%file_name%".replace("%block_count%", String.valueOf(count)).replace("%player_uuid%", player.getUniqueId().toString()).replace("%file_name%", buildingFile.getName())));
        } catch (IOException e) {
            getLogger().log(Level.SEVERE, "เกิดข้อผิดพลาดในการเขียนไฟล์ Binary (FAWE)!", e);
            player.sendMessage(applyPlaceholders(player, "§c[BuildingRecorder] เกิดข้อผิดพลาดในการบันทึก!"));
            if (useEconomy && recordCost > 0) economy.depositPlayer(player, recordCost);
        }
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (command.getName().equalsIgnoreCase("be")) {
            if (args.length == 1) {
                if (args[0].equalsIgnoreCase("reload")) {
                    if (sender.hasPermission("buildingrecorder.reload")) {
                        reloadConfig();
                        loadConfig();
                        sender.sendMessage(applyPlaceholders((Player) sender, "§a[BuildingRecorder] รีโหลดการตั้งค่าเรียบร้อยแล้ว!"));
                    } else {
                        sender.sendMessage(applyPlaceholders((Player) sender, "§c[BuildingRecorder] คุณไม่มีสิทธิ์ในการใช้งานคำสั่งนี้!"));
                    }
                    return true;
                } else if (args[0].equalsIgnoreCase("list")) {
                    if (sender instanceof Player) {
                        Player player = (Player) sender;
                        openBuildingListGUI(player);
                    } else {
                        sender.sendMessage("§c[BuildingRecorder] คำสั่งนี้ใช้ได้เฉพาะผู้เล่นเท่านั้น!");
                    }
                    return true;
                } else if (args[0].equalsIgnoreCase("place")) {
                    if (sender instanceof Player) {
                        Player player = (Player) sender;
                        placeBuilding(player);
                    } else {
                        sender.sendMessage("§c[BuildingRecorder] คำสั่งนี้ใช้ได้เฉพาะผู้เล่นเท่านั้น
